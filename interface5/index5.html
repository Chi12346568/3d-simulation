<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>3D Simulation Result</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f8f8f8;
        margin: 0;
        padding: 20px;
      }

      .frame {
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 12px;
        padding: 20px;
        max-width: 1100px;
        width: 95%;
        margin: auto;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        position: relative;
        overflow: hidden;
      }

      .lang-select {
        position: absolute;
        top: 20px;
        right: 20px;
      }

      .lang-select select {
        padding: 6px 10px;
        font-size: 14px;
        border: 1px solid #aaa;
        border-radius: 4px;
      }

      .title {
        color: #3333cc;
        font-size: 22px;
        margin-bottom: 20px;
      }

      .content {
        display: flex;
        gap: 20px;
        flex-direction: row;
        flex-wrap: wrap;
      }

      .box {
        flex: 1;
        background: #fff;
        border: 1px solid #ccc;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.05);
        min-height: 300px;
        min-width: 280px;
      }

      @media (max-width: 768px) {
        .content {
          flex-direction: column;
        }
        .box {
          width: 100%;
        }
      }

      .simulation-placeholder {
        background-color: #eaeaea;
        border: 2px dashed #ccc;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #666;
        font-size: 18px;
        position: relative;
      }

      #visualization-container {
        width: 100%;
        height: 300px;
        position: relative;
        overflow: hidden;
      }

      #3d-canvas {
        width: 100%;
        height: 100%;
        background-color: #f0f0f0;
        border-radius: 5px;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }

      #3d-canvas canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .generate-btn {
        padding: 10px 20px;
        background-color: #a8f5a8;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-weight: bold;
      }

      .generate-btn:hover {
        background-color: #8ae78a;
      }

      .generate-btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .highlight-green {
        color: green;
        font-weight: bold;
      }
      .highlight-blue {
        color: #3366cc;
        font-weight: bold;
      }
      .highlight-purple {
        color: #cc33cc;
        font-weight: bold;
      }

      .buttons {
        margin-top: 25px;
        display: flex;
        justify-content: flex-end;
        gap: 20px;
      }

      button {
        background-color: #a8f5a8;
        border: 1px solid #a8f5a8;
        padding: 10px 20px;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="frame">
      <!-- Language Switcher -->
      <div class="lang-select">
        <select id="language" onchange="changeLanguage(this.value)">
          <option value="en">üåê ENG</option>
          <option value="fr">üåê FR</option>
          <option value="ar">üåê AR</option>
        </select>
      </div>

      <h2 class="title" id="mainTitle">The 3D Simulation result</h2>

      <div class="content">
        <!-- Left box -->
        <div class="box" id="textContent">
          <h3>The finest Example</h3>
          <p>
            A real-life example of a stack is a
            <strong>stack of books</strong> on a desk.
          </p>
          <h4>How it Works:</h4>
          <ol>
            <li>
              When you <span class="highlight-green">add a new book</span> to
              the stack, it goes on top of the pile (pushed onto the stack).
            </li>
            <li>
              When you need a book, you take the
              <span class="highlight-blue">top book</span> from the stack (pop
              from the stack).
            </li>
            <li>
              The last book you added is the first one you‚Äôll remove, following
              the <span class="highlight-purple">LIFO</span> (Last In, First
              Out) principle.
            </li>
          </ol>
          <p>
            So, the most recently placed book is the first one you grab, just
            like how elements are added and removed from a stack in programming.
          </p>
        </div>

        <!-- Right box -->
        <div class="box">
          <div class="simulation-placeholder">
            <div id="visualization-container">
              <div id="3d-canvas">
                Click "Generate 3D Visualization" to create the visualization
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Buttons -->
      <div class="buttons">
        <button id="generateVisualizationBtn" class="generate-btn">
          Generate 3D Visualization
        </button>
        <button id="btnEdit">Edit the 3D simulation</button>
        <button id="btnDownload">Download the file</button>
      </div>
    </div>

    <script type="module">
      // Import Three.js using the import map
      import * as THREE from 'three'
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
      import { FontLoader } from 'three/addons/loaders/FontLoader.js'
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js'
      import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js'
      window.OrbitControls = OrbitControls
      window.FontLoader = FontLoader
      window.TextGeometry = TextGeometry
      window.GLTFExporter = GLTFExporter

      // Make THREE available globally for any code that might need it
      window.THREE = THREE
      // THREE.OrbitControls = OrbitControls

      function resetContainer() {
        // Get the simulation placeholder (main container)
        const simulationPlaceholder = document.querySelector(
          '.simulation-placeholder'
        )

        // Keep only the visualization container and reset it
        const visualizationContainer = document.getElementById(
          'visualization-container'
        )

        // Reset the visualization container to initial state
        visualizationContainer.innerHTML =
          '<div id="3d-canvas">Click "Generate 3D Visualization" to create the visualization</div>'
        visualizationContainer.removeAttribute('style')

        // Remove all other elements inside simulation-placeholder (the button rows)
        Array.from(simulationPlaceholder.children).forEach((child) => {
          // Keep only the visualization container
          if (child.id !== 'visualization-container') {
            simulationPlaceholder.removeChild(child)
          }
        })

        // Reset the simulation placeholder's style
        simulationPlaceholder.removeAttribute('style')
      }

      // OpenAI API key
      const OPENAI_API_KEY =
        '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'
      // Function to initialize the visualization with the imported module
      function initVisualization() {
        try {
          console.log('Three.js loaded successfully, version:', THREE.REVISION)

          // Log that we're using import maps
          console.log('Using ES modules with import maps for loading Three.js')

          // Validate that essential Three.js components are available
          if (
            !THREE ||
            !THREE.WebGLRenderer ||
            !THREE.Scene ||
            !THREE.PerspectiveCamera
          ) {
            throw new Error('Essential Three.js components are missing')
          }

          // Validate OrbitControls is available
          if (!THREE.OrbitControls) {
            console.warn(
              'OrbitControls not available. Some interactive features may be limited.'
            )
          }
          // Add a diagnostic utility to the window object
          window.check3DStatus = function () {
            return {
              threeJsVersion: THREE.REVISION,
              hasWebGL: !!window.WebGLRenderingContext,
              hasCanvas: typeof HTMLCanvasElement !== 'undefined',
              hasOrbitControls: typeof THREE.OrbitControls !== 'undefined',

              errors: window.scriptLoadingErrors || [],
            }
          }

          // Log diagnostics
          console.log('3D System Status:', window.check3DStatus())

          // Get the container for the simulation
          const simulationContainer = document.querySelector(
            '.simulation-placeholder'
          )

          // Load stored accessibility settings
          const accessibilitySettings = JSON.parse(
            localStorage.getItem('accessibilitySettings') || '[]'
          )

          // Get the concept we're visualizing from localStorage
          const chapterTopic =
            localStorage.getItem('chapterTopic') || 'Data Structure'
          const userPrompt =
            localStorage.getItem('userPrompt') || 'Stack data structure'
          const formattedExample = localStorage.getItem('formattedExample')

          // Get last prompt data if available
          const lastPromptData = localStorage.getItem('lastPromptData')
          let storedPromptData = null

          if (lastPromptData) {
            try {
              storedPromptData = JSON.parse(lastPromptData)
              console.log('Found stored prompt data:', storedPromptData)

              // Use stored prompt data if available
              if (storedPromptData && storedPromptData.concept) {
                // We have stored prompt data from previous steps
                console.log('Using stored prompt data from previous steps')
              }
            } catch (e) {
              console.error('Error parsing stored prompt data:', e)
            }
          }

          // If we have a formatted example, use it
          if (formattedExample) {
            document.getElementById('textContent').innerHTML = formattedExample
          }

          // Set the title
          document.getElementById(
            'mainTitle'
          ).textContent = `3D Simulation: ${chapterTopic}`

          // Get references to existing HTML elements
          const generateButton = document.getElementById(
            'generateVisualizationBtn'
          )
          const canvas = document.getElementById('3d-canvas')

          // Add event handlers for buttons
          document
            .getElementById('btnEdit')
            .addEventListener('click', function () {
              window.location.href = '../interface6/index6.html'
            })

          document
            .getElementById('btnDownload')
            .addEventListener('click', function () {
              downloadVisualization()
            })

          // Clean up any previous renderings
          cleanupThreeJsResources()

          // Handle the generate button click
          generateButton.addEventListener('click', async function () {
            resetContainer()
            generateButton.disabled = true
            generateButton.textContent = 'Generating...'
            canvas.textContent = 'Loading visualization...'

            try {
              // Use stored prompt data if available, otherwise create new prompt data
              let promptData

              if (storedPromptData) {
                promptData = storedPromptData
                console.log('Using stored prompt data for visualization')
              } else {
                promptData = {
                  concept: userPrompt,
                  accessibility: accessibilitySettings,
                  example: document.getElementById('textContent').innerText,
                }
                console.log('Creating new prompt data for visualization')
              }

              await generate3DVisualization(promptData, canvas)
              generateButton.textContent = 'Regenerate Visualization'

              // Save the button state to localStorage
              localStorage.setItem('buttonState', 'generated')
            } catch (error) {
              console.error('Error generating visualization:', error)
              canvas.textContent =
                'Error generating visualization: ' + error.message
            } finally {
              generateButton.disabled = false
            }
          })

          // Check if we should auto-generate the visualization (if coming from previous steps)
          const buttonState = localStorage.getItem('buttonState')
          if (buttonState === 'generated' && storedPromptData) {
            console.log('Auto-generating visualization from previous step data')
            // Trigger the generate button click after a short delay to ensure the page is fully loaded
            setTimeout(() => {
              generateButton.click()
            }, 500)
          }
        } catch (err) {
          console.log(err)
        }
      }

      // Function to generate 3D visualization using OpenAI
      async function generate3DVisualization(promptData, container) {
        try {
          // Save the current prompt data to localStorage so it persists across steps
          localStorage.setItem('lastPromptData', JSON.stringify(promptData))

          // Check if we have stored code from previous generation or editing
          const storedCode = localStorage.getItem('3dVisualizationCode')

          // Check if the prompt has changed since the last generation
          let previousPromptData = null
          let shouldRegenerate = !storedCode // Default: regenerate if no stored code

          const lastPromptDataString = localStorage.getItem(
            'lastPromptDataUsedForGeneration'
          )
          if (lastPromptDataString && storedCode) {
            try {
              previousPromptData = JSON.parse(lastPromptDataString)

              // Compare current promptData with previous to see if we need to regenerate
              const currentCustomInstructions =
                promptData.customInstructions || ''
              const previousCustomInstructions =
                previousPromptData.customInstructions || ''

              if (currentCustomInstructions !== previousCustomInstructions) {
                console.log(
                  'Prompt instructions changed, regenerating visualization'
                )
                shouldRegenerate = true
              }
            } catch (e) {
              console.error('Error comparing prompt data:', e)
              shouldRegenerate = true
            }
          }

          // Use stored code only if we shouldn't regenerate
          if (storedCode && !shouldRegenerate) {
            console.log('Using stored visualization code')
            executeVisualizationCode(storedCode, container)
            return
          }

          // If we already have a canvas but the prompt has changed, we need to clean up first
          if (document.querySelector('canvas') && shouldRegenerate) {
            console.log(
              'Canvas exists but prompt changed, cleaning up for regeneration'
            )
            cleanupThreeJsResources()
            container.innerHTML =
              'Regenerating visualization with new instructions...'
          }
          // Otherwise, if we have a canvas and no changes, skip generation
          else if (document.querySelector('canvas') && !shouldRegenerate) {
            console.log(
              'Canvas already exists with current instructions, skipping generation'
            )
            return
          }

          // Call OpenAI API to generate Three.js code
          const response = await fetch(
            'https://api.openai.com/v1/chat/completions',
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${OPENAI_API_KEY}`,
              },
              body: JSON.stringify({
                model: 'gpt-4.1',
                messages: [
                  {
                    role: 'system',
                    content: `You are a 3D visualization expert specializing in educational Three.js visualizations specifically for computer science concepts, data structures and algorithms.
                Create compact, well-structured Three.js WITHOUT the \`\`\`javascript code to visualize computer science concepts.

                TECHNICAL REQUIREMENTS:
                1. Scene Setup: Initialize a scene with proper lighting, camera, and renderer in a <div> with id '3d-canvas'.
                2. Simple Geometry: Use basic geometries (boxes, spheres, cylinders) with distinct colors.
                3. Limited Scope: Focus on a small, manageable visualization that clearly demonstrates the concept.
                4. Error Handling: Include try/catch blocks for robust error handling.
                5. Performance: Optimize for performance with simple materials and limited objects.
                6. Interactivity: Add buttons for key operations (e.g., push/pop for stacks).
                7. Animation: Include smooth animations for operations.
                8. Code Structure: Include setup, animation, and interaction functions.
                9. use Oribit controls for any UI elements you want to render, do not inject any extra buttons into the dom
                10. Instead of THREE.OrbitControls or THREE.FontLoader use OribitControls or FontLoader directly
                11. Exceot three.js there's no other library installed
                13. Do not come up with buggy or unexpected code, everything that you need to know you already know, do not guess that an element might exist or guess a class name or that a library is existing.
                14. if you have to add a button, add them to the bottom as small flex elements the the EXISTING .simulation-placeholder div
                15. Orbit controls are available in globally in the current window

                WHAT TO CREATE FOR DIFFERENT CONCEPTS:
                - For data structures (stacks, queues, linked lists, trees):
                  * Create visual representations of the structure with boxes/nodes
                  * Add buttons for operations (add, remove, search)
                  * Show animations for these operations

                - For algorithms (sorting, searching):
                  * Create arrays of objects that can be manipulated
                  * Show step-by-step execution with animations
                  * Add buttons to step through algorithm or run automatically

                - For concepts (OOP, recursion, etc.):
                  * Create metaphors with simple objects
                  * Use animations to show relationships
                  * Include interactive elements to demonstrate the concept
              
                  * VISUALIZATION GUIDELINES:
                - All code should be in javascript (NO HTML OR CSS) and use Three.js for all rendering
                - try to provide VERY close objects to what described
                - Just return the code, no explanations or comments or even markdown
                - Create a SIMPLE and FOCUSED visualization with 5-10 objects maximum
                - Use bright, contrasting colors (red, green, blue, yellow) for key elements
                - Add a control panel with 2-4 buttons for basic operations
                - Include text labels for important parts
                - Implement smooth transitions/animations (0.5-1 second) for operations
                - Add clear lighting so all objects are visible
                - Make the camera view the entire scene without needing to rotate (optional OrbitControls for exploration)
                - Ensure all text is readable and elements are distinguishable
                - Handle window resize events
                - Include proper error handling throughout the code
                - Make sure the code is COMPLETE and can be run directly in a browser and visible to all users
                - You need to render your code the canvas element which is the only canvas in the document

                ITEMS TO AVOID:
                - DO NOT Create new ui elements or render add html stuff to the canvas container, it's only for 3d visualizations
                - DO NOT hide the canvas, if you want to add buttons, add them horizontally and a small size at the bottom of the already exisint canvas container
                - Do NOT create complex scenes (no theme parks, cities, elaborate environments)
                - Do NOT add unnecessary decorative elements that don't relate to the concept
                - Do NOT create realistic physics simulations or overly complex animations
                - Do NOT add complex textures or materials that might impact performance
                - DO NOT manipulate the size of any elements, use what you have
                - DO NOT use TWEEN Or any OTHER library, the only library on hand is Three.js
                - DO NOT use THREE. for FontLoader or OrbitControls or TextGeometry, use them directly
                - DO NOT Create a new canvas use the already provided one for you
                - DO NOT Use '#3d-canvas canvas' in querySelector simply use 'canvas'
                - DO NOT Play or change the UI or sizes in any way, the UI is made by professionals to ensure user experience

                Return ONLY executable JavaScript code with no explanations, comments are allowed.`,
                  },
                  {
                    role: 'user',
                    content: `Create a 3D visualization for: ${
                      promptData.concept
                    }

                Example explanation: ${promptData.example}

                Accessibility considerations: ${promptData.accessibility.join(
                  ', '
                )}

                ${promptData.content}

                EXAMPLE: For a stack, create 3-5 colored blocks that can be pushed onto/popped from a stack with buttons for push/pop operations.

                Focus on creating something EDUCATIONAL and INTERACTIVE that works reliably. and try to make them real cartoonish objects not just simple blocks or spheres
                Add the threejs scene to the WINDOW object to be able to access it via window.scene
                Final Notes:
                DO NOT FORMAT YOUR CODE, DO NOT USE ANY MARKDOWN SYNTAX WE WILL NOT BE ABLE TO EVAL IT
                `,
                  },
                ],
                temperature: 0.5, // Lower temperature for more deterministic output
                max_tokens: 10000, // Increased token limit for more complete code
              }),
            }
          )

          const result = await response.json()
          if (result.error) {
            throw new Error(result.error.message)
          }

          // Get the generated code
          const generatedCode = result.choices[0].message.content.trim()

          // Basic validation check
          if (!generatedCode || generatedCode.length < 200) {
            console.error('Generated code appears to be incomplete')
            throw new Error(
              'The visualization code was too short or incomplete'
            )
          }

          // Check for some basic Three.js components that should be present
          const hasRenderer = generatedCode.includes('WebGLRenderer')
          const hasScene = generatedCode.includes('Scene')
          const hasCamera = generatedCode.includes('Camera')

          if (!hasRenderer || !hasScene || !hasCamera) {
            console.warn(
              'Generated code may be missing essential Three.js components'
            )
          }

          try {
            // Validate generated code
            const validationResult = validateVisualizationCode(generatedCode)

            if (validationResult.valid) {
              console.log('Generated code validation passed')
              // Save the code to localStorage
              localStorage.setItem('3dVisualizationCode', generatedCode)

              // Execute the generated code
              container.innerHTML = '' // Clear existing content
              executeVisualizationCode(generatedCode, container)

              // If there were non-critical issues, log them but don't break execution
              if (validationResult.issues.length > 0) {
                console.warn(
                  'Non-critical issues in code:',
                  validationResult.issues
                )
              }
            } else {
              console.error(
                'Generated code validation failed:',
                validationResult.issues
              )
              throw new Error(
                `Generated code has issues: ${validationResult.issues.join(
                  ', '
                )}`
              )
            }
          } catch (validationError) {
            console.error('Validation error:', validationError)

            // Even if validation fails, we'll still try to execute the code
            // as it might be a false positive
            console.warn('Attempting to execute code despite validation issues')
            localStorage.setItem('3dVisualizationCode', generatedCode)
            container.innerHTML = '' // Clear existing content
            executeVisualizationCode(generatedCode, container)
          }

          // After successful generation, store the promptData used for this generation
          localStorage.setItem(
            'lastPromptDataUsedForGeneration',
            JSON.stringify(promptData)
          )
        } catch (error) {
          console.error('Error generating 3D code:', error)
          container.textContent = 'Error: ' + error.message
        }
      }

      window.handleVisualizationError = () => {}
      // Function to safely execute the generated code
      function executeVisualizationCode(code, container) {
        try {
          const canvas = document.getElementById('3d-canvas')
          // Clear any previous content
          canvas.innerHTML = ''

          // Check if there's already a canvas element, if not create one
          let canvasElement = canvas.querySelector('canvas')
          if (!canvasElement) {
            canvasElement = document.createElement('canvas')
            canvasElement.style.width = '100%'
            canvasElement.style.height = '100%'
            canvas.appendChild(canvasElement)
          }

          // Set explicit dimensions to ensure the canvas is visible
          canvas.style.height = '300px'
          canvas.style.width = '100%'

          // Prepare the code with better error handling and validation
          const processedCode = `
            try {
              // Global error tracking
              window.visualizationErrors = [];

              // Set up global animation tracking
              window.animationFrameId = window.animationFrameId || null;
              
              // Initialize global scene reference for exporting
              window.scene = null;
              window.camera = null;
              window.renderer = null;

              // Create a safety wrapper for requestAnimationFrame
              const originalRequestAnimationFrame = window.requestAnimationFrame;
              window.requestAnimationFrame = function(callback) {
                window.animationFrameId = originalRequestAnimationFrame(callback);
                return window.animationFrameId;
              };

              // Ensure there's a canvas in the container
              const container = document.getElementById('3d-canvas');
              let canvasElement = container.querySelector('canvas');
              if (!canvasElement) {
                canvasElement = document.createElement('canvas');
                canvasElement.style.width = '100%';
                canvasElement.style.height = '100%';
                container.appendChild(canvasElement);
              }

              // Set up a resize handler to maintain canvas dimensions
              window.visualizationResizeHandler = function() {
                const canvasElement = document.querySelector('canvas');
                if (canvasElement && window.renderer) {
                  const container = document.getElementById('3d-canvas');
                  const width = container.clientWidth;
                  const height = container.clientHeight;
                  
                  canvasElement.style.width = width + 'px';
                  canvasElement.style.height = height + 'px';
                  
                  if (window.camera) {
                    window.camera.aspect = width / height;
                    window.camera.updateProjectionMatrix();
                  }
                  
                  if (window.renderer) {
                    window.renderer.setSize(width, height);
                  }
                }
              };
              
              // Add the resize listener
              window.addEventListener('resize', window.visualizationResizeHandler);

              // Catch errors in the animation loop
              window.addEventListener('error', function(event) {
                console.error('Runtime error in visualization:', event.error);
                window.visualizationErrors.push(event.error.message);
                if (window.animationFrameId) {
                  cancelAnimationFrame(window.animationFrameId);
                }
                window.handleVisualizationError(event.error);
                return true; // Prevent default error handler
              });

              // Main visualization code
              ${code}

              // Run the resize handler once to set initial dimensions
              window.visualizationResizeHandler();

              console.log('3D visualization loaded successfully');
            } catch(error) {
              console.error('Error in visualization code:', error);
              window.handleVisualizationError(error);
            }
          `

          // Create and execute the visualization function
          const executeCode = new Function(
            'container',
            'canvas',
            'THREE',
            'canvasElement',
            processedCode
          )

          // Execute the code with the Three.js library
          if (typeof THREE !== 'undefined') {
            executeCode(container, canvas, THREE, canvasElement)
          } else {
            throw new Error(
              'Three.js library is not loaded. Please ensure it is loaded before generating the visualization.'
            )
          }
        } catch (error) {
          console.error('Error setting up visualization:', error)
          container.innerHTML = `
            <div style="padding: 20px; background-color: #fff0f0; border: 1px solid #ffcccc; border-radius: 5px;">
              <h3 style="color: #cc0000; margin-top: 0;">Visualization Error</h3>
              <p>${error.message}</p>
              <p>Please try regenerating the visualization or refresh the page.</p>
              <button onclick="location.reload()">Refresh Page</button>
            </div>
          `
        }
      }

      // Helper function to clean up Three.js resources
      function cleanupThreeJsResources() {
        try {
          // Remove any existing canvases
          const existingCanvas = document.querySelectorAll('canvas')
          existingCanvas.forEach((canvas) => {
            if (canvas.parentNode) {
              canvas.parentNode.removeChild(canvas)
            }
          })

          // Cancel any animation frames
          if (window.animationFrameId) {
            cancelAnimationFrame(window.animationFrameId)
            window.animationFrameId = null
          }

          // Remove any global event listeners
          if (window.visualizationResizeHandler) {
            window.removeEventListener(
              'resize',
              window.visualizationResizeHandler
            )
            window.visualizationResizeHandler = null
          }

          console.log('Cleaned up Three.js resources')
        } catch (error) {
          console.error('Error cleaning up Three.js resources:', error)
        }
      }

      // Function to validate the generated code for common issues
      function validateVisualizationCode(code) {
        const issues = []

        // Check if code is a reasonable length
        if (code.length < 200) {
          issues.push('Code is too short')
          return { valid: false, issues }
        }

        // Check if code has essential Three.js components
        const requiredTerms = [
          'WebGLRenderer',
          'Scene',
          'Camera',
          'requestAnimationFrame',
          'renderer.render',
        ]

        requiredTerms.forEach((term) => {
          if (!code.includes(term)) {
            issues.push(`Missing ${term}`)
          }
        })

        // Check for syntax errors
        try {
          new Function(code)
        } catch (e) {
          issues.push(`Syntax error: ${e.message}`)
          return { valid: false, issues }
        }

        // Check for common issues
        if (
          code.includes('document.body.appendChild') &&
          !code.includes('3d-canvas')
        ) {
          issues.push(
            'Code might append to document.body instead of the container'
          )
        }

        if (
          code.includes('window.addEventListener') &&
          !code.includes('removeEventListener')
        ) {
          issues.push(
            'Event listener added but not removed (potential memory leak)'
          )
        }

        // Check for potentially harmful code (basic security check)
        const suspiciousPatterns = [
          'eval(',
          'localStorage.clear',
          'document.cookie',
          'window.open',
          'location.href',
          'window.location',
        ]

        suspiciousPatterns.forEach((pattern) => {
          if (code.includes(pattern)) {
            issues.push(`Contains potentially unsafe code: ${pattern}`)
          }
        })

        // Return validation result
        return {
          valid:
            issues.length === 0 ||
            issues.every(
              (issue) =>
                issue.includes('Event listener') ||
                issue.includes('might append')
            ), // Allow minor issues but fail on major ones
          issues,
          codeStats: {
            length: code.length,
            lines: code.split('\n').length,
          },
        }
      }

      function changeLanguage(lang) {
        const text = document.getElementById('textContent')
        const title = document.getElementById('mainTitle')
        const btnEdit = document.getElementById('btnEdit')
        const btnDownload = document.getElementById('btnDownload')

        text.style.direction = lang === 'ar' ? 'rtl' : 'ltr'
        text.style.textAlign = lang === 'ar' ? 'right' : 'left'

        if (lang === 'en') {
          title.textContent = 'The 3D Simulation result'
          btnEdit.textContent = 'Edit the 3D simulation'
          btnDownload.textContent = 'Download 3D Model'

          // Load English content from localStorage if available
          const formattedExample = localStorage.getItem('formattedExample')
          if (formattedExample) {
            text.innerHTML = formattedExample
          } else {
            text.innerHTML = `
            <h3>The finest Example</h3>
            <p>A real-life example of a stack is a <strong>stack of books</strong> on a desk.</p>
            <h4>How it Works:</h4>
            <ol>
              <li>When you <span class="highlight-green">add a new book</span> to the stack, it goes on top of the pile (pushed onto the stack).</li>
              <li>When you need a book, you take the <span class="highlight-blue">top book</span> from the stack (pop from the stack).</li>
              <li>The last book you added is the first one you'll remove, following the <span class="highlight-purple">LIFO</span> (Last In, First Out) principle.</li>
            </ol>
            <p>So, the most recently placed book is the first one you grab, just like how elements are added and removed from a stack in programming.</p>
          `
          }
        } else if (lang === 'fr') {
          title.textContent = 'R√©sultat de la simulation 3D'
          btnEdit.textContent = 'Modifier la simulation 3D'
          btnDownload.textContent = 'T√©l√©charger le mod√®le 3D'

          text.innerHTML = `
          <h3>Le meilleur exemple</h3>
          <p>Un exemple r√©el d'une pile est une <strong>pile de livres</strong> sur un bureau.</p>
          <h4>Comment √ßa fonctionne :</h4>
          <ol>
            <li>Quand vous <span class="highlight-green">ajoutez un nouveau livre</span> √† la pile, il va au-dessus (pouss√© sur la pile).</li>
            <li>Quand vous avez besoin d'un livre, vous prenez le <span class="highlight-blue">livre du dessus</span> (d√©pilage).</li>
            <li>Le dernier livre ajout√© est le premier que vous retirerez, selon le principe <span class="highlight-purple">LIFO</span> (Dernier Entr√©, Premier Sorti).</li>
          </ol>
          <p>Ainsi, le livre le plus r√©cemment plac√© est le premier que vous prenez, comme dans une pile en programmation.</p>
        `
        } else if (lang === 'ar') {
          title.textContent = 'ŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿ´ŸÑÿßÿ´Ÿäÿ© ÿßŸÑÿ£ÿ®ÿπÿßÿØ'
          btnEdit.textContent = 'ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿ´ŸÑÿßÿ´Ÿäÿ© ÿßŸÑÿ£ÿ®ÿπÿßÿØ'
          btnDownload.textContent = 'ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÜŸÖŸàÿ∞ÿ¨ ÿ´ŸÑÿßÿ´Ÿä ÿßŸÑÿ£ÿ®ÿπÿßÿØ'

          text.innerHTML = `
          <h3>ÿ£ŸÅÿ∂ŸÑ ŸÖÿ´ÿßŸÑ</h3>
          <p>ŸÖÿ´ÿßŸÑ ÿ≠ŸÇŸäŸÇŸä ÿπŸÑŸâ ÿßŸÑŸÖŸÉÿØÿ≥ ŸáŸà <strong>ŸÉŸàŸÖÿ© ŸÖŸÜ ÿßŸÑŸÉÿ™ÿ®</strong> ÿπŸÑŸâ ÿßŸÑŸÖŸÉÿ™ÿ®.</p>
          <h4>ŸÉŸäŸÅ ŸäÿπŸÖŸÑ:</h4>
          <ol>
            <li>ÿπŸÜÿØŸÖÿß <span class="highlight-green">ÿ™ÿ∂ŸäŸÅ ŸÉÿ™ÿßÿ®Ÿãÿß ÿ¨ÿØŸäÿØŸãÿß</span> ÿ•ŸÑŸâ ÿßŸÑŸÉŸàŸÖÿ©ÿå ŸÅÿ•ŸÜŸá ŸäŸàÿ∂ÿπ ŸÅŸä ÿßŸÑÿ£ÿπŸÑŸâ (ŸäŸèÿ∂ÿßŸÅ ÿ•ŸÑŸâ ÿßŸÑŸÖŸÉÿØÿ≥).</li>
            <li>ÿπŸÜÿØŸÖÿß ÿ™ÿ≠ÿ™ÿßÿ¨ ÿ•ŸÑŸâ ŸÉÿ™ÿßÿ®ÿå ÿ™ÿ£ÿÆÿ∞ <span class="highlight-blue">ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑÿπŸÑŸàŸä</span> ŸÖŸÜ ÿßŸÑŸÉŸàŸÖÿ© (ÿ•ÿ≤ÿßŸÑÿ© ŸÖŸÜ ÿßŸÑÿ£ÿπŸÑŸâ).</li>
            <li>ÿ¢ÿÆÿ± ŸÉÿ™ÿßÿ® ÿ£ÿ∂ŸÅÿ™Ÿá ŸáŸà ÿ£ŸàŸÑ ŸÖŸÜ ÿ≥ÿ™ÿ≤ŸäŸÑŸáÿå ÿ≠ÿ≥ÿ® ŸÖÿ®ÿØÿ£ <span class="highlight-purple">LIFO</span> (ÿßŸÑÿ£ÿÆŸäÿ± ŸäÿØÿÆŸÑÿå ÿßŸÑÿ£ŸàŸÑ ŸäÿÆÿ±ÿ¨).</li>
          </ol>
          <p>ŸÑÿ∞ÿßÿå ŸÅÿ•ŸÜ ÿßŸÑŸÉÿ™ÿßÿ® ÿßŸÑŸÖÿ∂ÿßŸÅ ŸÖÿ§ÿÆÿ±Ÿãÿß ŸáŸà ÿ£ŸàŸÑ ŸÖÿß ÿ™ÿ£ÿÆÿ∞Ÿáÿå ÿ™ŸÖÿßŸÖŸãÿß ŸÖÿ´ŸÑ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä ŸÖŸÉÿØÿ≥ ÿßŸÑÿ®ÿ±ŸÖÿ¨ÿ©.</p>
        `
        }
      }

      // Initialize global error tracking
      window.scriptLoadingErrors = []

      // Check browser compatibility
      function checkBrowserCompatibility() {
        const canvas = document.createElement('canvas')
        let hasWebGL = false
        try {
          hasWebGL = !!(
            window.WebGLRenderingContext &&
            (canvas.getContext('webgl') ||
              canvas.getContext('experimental-webgl'))
          )
        } catch (e) {
          hasWebGL = false
        }

        return {
          webgl: hasWebGL,
          supported: hasWebGL,
          browser: navigator.userAgent,
        }
      }

      // On page load with enhanced loading and error handling
      window.onload = function () {
        // Check browser compatibility first
        const compatibility = checkBrowserCompatibility()
        if (!compatibility.webgl) {
          console.warn('WebGL not supported in this browser')
        }

        window.addEventListener('resize', window.visualizationResizeHandler)

        // Initialize the 3D visualization
        initVisualization()

        // Check if we're coming from a completed step
        const stepsCompleted = localStorage.getItem('stepsCompleted')
        if (stepsCompleted === 'true') {
          console.log('Steps completed, ensuring visualization is loaded')

          // If we have a stored visualization code but no canvas yet, create one
          const storedCode = localStorage.getItem('3dVisualizationCode')
          if (storedCode && !document.querySelector('canvas')) {
            const canvas = document.getElementById('3d-canvas')
            executeVisualizationCode(storedCode, canvas)
          }
        }
      }

      // Function to download the visualization as GLB and prompt as TXT
      async function downloadVisualization() {
        try {
          // Check if a visualization is currently available
          const canvas = document.querySelector('canvas')
          if (!canvas || !window.scene) {
            alert('Please generate a 3D visualization first.')
            return
          }

          // Create a ZIP folder for downloads
          const downloadItems = []
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
          const zipFilename = `3d-visualization-${timestamp}`

          // 1. Export the 3D scene to GLB
          const exporter = new GLTFExporter()

          // Get the current scene from the global window object
          const scene = window.scene

          // Export as GLB (binary)
          exporter.parse(
            scene,
            function (result) {
              if (result instanceof ArrayBuffer) {
                // Create GLB blob
                const blob = new Blob([result], {
                  type: 'application/octet-stream',
                })
                downloadFile(blob, `${zipFilename}.glb`)

                // Create and download prompt data as TXT file
                const promptData = localStorage.getItem('lastPromptData')
                if (promptData) {
                  try {
                    const parsedData = JSON.parse(promptData)
                    let promptText = `Concept: ${
                      parsedData.concept || 'N/A'
                    }\n\n`
                    promptText += `Example:\n${parsedData.example || 'N/A'}\n\n`
                    promptText += `Accessibility considerations:\n${(
                      parsedData.accessibility || []
                    ).join(', ')}\n\n`
                    if (parsedData.customInstructions) {
                      promptText += `Custom Instructions:\n${parsedData.customInstructions}\n\n`
                    }

                    const textBlob = new Blob([promptText], {
                      type: 'text/plain',
                    })
                    downloadFile(textBlob, `${zipFilename}-prompt.txt`)
                  } catch (e) {
                    console.error('Error parsing prompt data:', e)
                    alert(
                      'The 3D model was exported, but there was an issue exporting the prompt data.'
                    )
                  }
                }
              } else {
                console.error('Error exporting GLB:', result)
                alert('There was an error exporting the 3D model.')
              }
            },
            function (error) {
              console.error('Error exporting GLB:', error)
              alert(
                'There was an error exporting the 3D model: ' + error.message
              )
            },
            { binary: true } // Export as GLB
          )
        } catch (error) {
          console.error('Error in download process:', error)
          alert('Error during download: ' + error.message)
        }
      }

      // Helper function to download a file
      function downloadFile(blob, filename) {
        const link = document.createElement('a')
        link.href = URL.createObjectURL(blob)
        link.download = filename
        link.click()
        URL.revokeObjectURL(link.href)
      }
    </script>
  </body>
</html>
